### 转数字：
NaN的情况：
* undefined,
* {}/{name:""},
* '123字符串'

0的情况：
* false
* null

true转为1

### 转布尔值
几种专为false的情况：
* 0
* -0
* undefined
* null
* NaN
* ''

## 基础运算符
### 一元运算符
#### 数学
% 取余 
a % b 的结果是a整除b 的余数
** 求幂
求几次方
### +号
用于字符串拼接：
**只要有任意一个字符元另外一个也会转换为字符串**
按照顺序工作
console.log('1'+2+1);//121 ‘1’+2 = ‘12’+1  = ‘121 先执行字符串拼接，再执行数组加运算符
console.log(2+2+'1');//41 先执行加运算符，再执行拼接字符串
### 二元运算符（两个运算元参与运算）
* 唯一支持字符串运算，其他都只支持数字
* 将运算元转换为数字
### 一元运算符 +（一个运算元参与运算）
* 对数字没用 +（-2） = -2
* 对其他数字。会将其转换为数字
* 效果等同于Number（）
### 运算符优先级
* 一元运算符优先级最高
* 赋值运算优先级最低
* 逗号运算符更低

## 值的比较
* 大于>
* 小于<
* 等于 == 
* 不等于 ！=
 
### 比较运算符
1. 不同类型的值进行比较，先转换为数字在比较大小
2. 字符串类型比较会根据“词典”顺序逐字符的比较大小
普通相等无法区分0 和false 

* 严格相等 ===  
* 严格不想等 ！==
需要区分 0和 false的时候使用
不会做类型的转换
### undefined和null的比较
undefined===null //false
undefeated == null //true 因为都转为 0
### null 和 0 的比较
null ==0 //false
null>0 //false
null >=0 //true 

### undefined 和 0 的比较
undefined ==0 //false
undefined >0 //false
undefined >=0 //false
**在全等情况下undefined和null只会和各自相等，不会和任何数相等**

### 空值合并运算符??
 1. 所第一个参数不是null或者不是undefined 则？？返回第一个参数，否则返回第二个参数
 2. 提供了一种从列表中选择第一个 “已定义”的值的简便方式
 被用于为变量分配默认值
 3.？？优先级非常低， 仅高于 = 和 ？ 在使用的时候，要加括号
 4.没有明确加括号， 不能和 ｜｜ 或者 && 一起使用
 
 ## 循环
 * wihle
 * for 
 ### 跳出循环
 * break  跳出循环 
 * continue 跳出本次循环
 * outher: for(...)标签标注法，指定标签。可以跳出这个循环

###  switch语句
* case 语句执行**严格相等**
* 没有breach 后面的语句都会执行
* 任何表达式都可以成为switch/case的参数
* 可以对case进行分组 
  case 3:
  case 6:
  ...;
  breack;
switch (x){
    case 'value1': //if (x==='value1') 严格相等
    console.log(1);
    break;
    case 'value2':
        console.log(2);
        break;
        default:
            console.log('nodefined');
            break
}

## 函数
1.  函数可以从内访问外部的变量，外部无法看到内部的局部变量
2.  函数可以没有返回值，没有的时候返回的是undefined

函数参数：
* 参数 parameter（范围）：是函数声明是括号内列出的变量（ 形参）
* 参数 argument  是函数在调用时传递给函数的值（实参）

默认值：
1. 使用 = 为函数声明中的参数指定所谓的默认值
foo(from,text='xxx'){}
2. 参数默认值可以用更复杂的表达式/函数，并且只会在缺少参数才会被计算和分配 

返回值：
* 空值的return 或 没有return的函数返回值都为undefined
* return 代码跨多行 可以加上括号

### 定义函数的方式
1. 函数声明 
function sayHi(){}
结尾没有分号
2. 函数表达式 
let hi = function () {}
结尾有分号因为是在执行赋值语句

#### 函数是一个值，不加（）是输出函数体的字符串，加括号是调用

### 回调函数 
### 匿名函数

### 函数声明 vs 函数表达式
1. 语法 赋值语句和单独的语句
2. 创建时机
    函数表达式： 在执行赋值语句的时候创建
    函数声明：在被定义之前，就可以被调用。函数声明在其被**声明的代码块内的任何位置** 都是可见的。
3. 作用域
    函数声明：仅作用于本作用域
    函数表达式：赋值操作全局都可见

## 箭头函数
书写方式：
* 不带花括号，可以直接书写函数计算表达式，并返回其结果，不需要return
* 带花括号 ，必须显示的return来返回一些内容

## 八种数据类型
* number
* string
* bigint -- 任意长度的整数
* boolean
* undefined
* null 
* object
* symbol

## 调试工具

## 使用ESLint
1. 安装node。js
2. npm install -g eslint
3. 根目录下创建一个 .eslintrc的配置文件
4. 在集成了 ESLint 的编辑器中安装/启用插件。大多数编辑器都有这个选项

## polyfills和转译器
* polyfills 垫片
    * core js 
    * polyfill.io
* Transpilers 转译器
  * babel

## 对象
### 创建方式
 * 构造函数语法 let user = new Object() 
 * 字面量语法 let user = {}

### 计算属性
 * 在对象字面量中使用方括号，这叫计算属性
 * 从属性名中读取应该是从方括号中的变量中获取
 * 允许任何属性名和变量

### 属性名称限制
 * 没有任何限制，可以使用关键字和保留字
 * 当数字0 被用作对象属性的键时，会被转换为字符串 “0”

### 访问
* 点符号
* 方括号，允许读取变量

### delete 删除属性


 ### 检查属性是否存在 in 操作符
 
 ### for...in 循环
 遍历一个对象的所有键
 **对于一个整数会有排序** 

### 对象的引用和复制
* 对象储存的是改对象的“在内存中的地址”--换句话说就是该对象的引用
* 当一个对象变量被复制 --引用被复制，而该对象自身并没有被复制

### 对象的比较
* 当引用同一个地址值，相等
* 当两个对象都为空时，不相等

### 克隆与合并
#### 浅拷贝 Object.assgin（）用法
* 第一个参数指目标对象
* 后面的参数是原对象,可以使用数组，会对数组的内容进行拼接
* 如果被拷贝的属性的属性名已经存在，那么它会被覆盖
* 代替for in 进行简单克隆

### 深层克隆
object.assgin / ...扩展运算符 对于基本数据类型可以使用，但对于对象里面的引用类型无法使用。

**使用const声明的对象也是可以被修改的**

## 垃圾回收
### 可达性 
1. 可达值的基本集合，不能被释放的值（不会被垃圾回收的）：
* 当前执行的函数。它的局部变量和参数
* 当前函数嵌套调用链上的其他函数， 它们的局部变量和参数 （闭包）
* 全局变量
* 内部的变量 （根） window？
2. 一个值通过引用或者引用链从根访问任何其他值，则认为该值是可达的
例如：全局变量中有一个对象，并且该对象的属性引用了另一个对象，则该对象是可达的
3. 一个对象的源对象没有引用其下面的对象，也会从内存中被删除

### 内部算法 
定期执行垃圾回收步骤
1. 垃圾收集器找到所有的根，并记住他们
2. 遍历并标记来自他们的所有引用
3. 遍历标记的的对象，并标记他们的引用，所有遍历到的对象都会被记住， 以免将来再次遍历到从一个对象
4. 重复操作，直到所有可达的引用都被访问到
5. 没有被标记的对象会被删除

### 优化建议
* 分代收集：对象被分为新的和旧的，旧的检查频率会减少
* 增量收集：将垃圾收集工作分成几部分来做 
* 闲时收集  cpu空闲的时候来允许

### 总结垃圾回收
* 垃圾回收是自动完成的，无法强制执行或者阻止执行
* 当对象是可达状态，他一定存在内存中
* 当引用的根引用不可达，一组相互连接的对象整体都不可达

## this
### 方法中的this
* this的值就是在点之前的这个对象， 即调用该方法的对象
* this是在代码运行时计算的，取决于代码上下文
* 在没有对象的情况下 this是全局对象window

### 箭头函数没有自己的this
* this取决于外部“正常”的函数

## 构造器和操作符“new”
### 构造函数
* 命名以大写字母开头（约定俗成）
* 只能有new操作符来执行

### new操作符执行时的步骤
1. 一个新的空对象被创建并分配给this
2. 函数体执行时，会修改this， 为其添加新的属性
3. 返回this的值

### 函数构造器的目的是--实现可重用的对象创建代码

**new function （立即调用的构造函数）不能被再次调用，因为他不保存在任何地方，只是被创建和调用**

### 在某些库的源码可能会加上这么一句
if (!new.target) { // 如果你没有通过 new 运行我
    return new User(name); // ……我会给你添加 new
  }
这表示无论是否使用new 程序都能正常工作

### 构造器的return
通常构造器是没有return语句，他的任务是将所有必要的东西写入this
* 如果return返回的是一个对象， 则返回这个对象，而不是this
* 如果return返回的是一个原始类型，则忽略
ps: return只返回带有的对象，其他都返回this

### 可选链" ？."-----对象出现不存在属性的问题 
 检查左边部分是否为undefined，如果是直接返回undefined
语法： let user = null
user?.address?.street //undefined
注意：
* 不要过度使用可选链
* ？.前的变量必须已经声明
* 会产生短路效应
* 其他变体： ?.() 调用函数 ?.[]方括号访问属性

总结：
* obj?.prop
* obj?.[prop]
* obj?.method()


## symbol类型
规范： 属性健只能是字符串类型或者Symbol类型
* 所有的symbol都是不同的
* Symbol不会被自动转换为字符串
* symbol作为键，不会被意外访问到， 是属于隐藏属性，可以和同类的字符串一起使用，但两者完全不相同
* 在对象字面量中使用Symbol，需要使用方括号括起来
* Symbol在for...in中会被跳过,Object.keys()也会被跳过
* Object.assgin 会复制Symbol
* Symbol.for(key)会创建一个全局的Symbol，全局Symbol注册相等的Symbol；
* Symbol.keyFor(key)返回Symbol（）填入的描述(只适用于Symbol.for()创建的全局Symbol)

使用场景：
* 隐藏属性对象
* js使用了许多Symbol
从技术上说，Symbol 不是 100% 隐藏的。有一个内建方法 Object.getOwnPropertySymbols(obj) 允许我们获取所有的 Symbol。还有一个名为 Reflect.ownKeys(obj) 的方法可以返回一个对象的 所有 键，包括 Symbol。所以它们并不是真正的隐藏。但是大多数库、内建方法和语法结构都没有使用这些方法。


## 对象原始值转换
转换规则：
1. 所有的对象转布尔值都为true
2. 数值转换在Data对象中可以相减
3. 字符串转换通常发生在alert（obj）这样一个输出对象

类型转换三种变体
* 对象转string  是指对一个期待字符串的对象执行操作时，例如alert 转为：[object Object] ===>先调用obj.toString或者obj.valueOf()
* 对象转number 是指进行数学运算时 ===>先调用obj.valueOf()再调用obj.toString()
* default 在少数情况下发生，当运算符不确定期望值的类型 例如： 二元加法，二元加法可以用于数字的相加也可以用于字符串拼接 ===>先调用obj.valueOf()再调用obj.toString()

转换方法：
1. 调用obj[Symbol.toPrimitive] 系统Symbol的方法
2. 字符串转换转 toString()优先 再valueOf()
3. 数学运算number/default 优先valueOf再toString()

obj.toString()返回一个字符串 "[object Object]"
obj.valueof()返回对象自身 

## obj[Symbol.toPrimitive]
let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

## 数据转换合集
1. 其他类型转布尔值
六种为false： 0 -0 null undefined NaN ""
2. 比较运算符 
转数字
3. 数学运算
转数字
4. 二元+ 
有字符串 是拼接字符串 
5. 其他类型转数字
null :0
false:0
"":0
Undefined :NaN
{}:NaN
'zifuchuan‘:NaN
6. 其他类型转字符串
对象/数组转字符串 [object Object]
 
其他直接是加引号
7. 对象进行转其他类型
转字符串 ：toString()
转数字： valueOf 

## 原始数据类型的方法
js允许访问字符串，数字，布尔值，和symbol的方法和属性，为了他们能够起作用，创建了提供额外功能的特殊“对象包装器”使用后被销毁
例子：str.toUpperCase() 包装对象的操作过程：
1. 在访问属性的时候，会创建一个**包含字符串字面值的特殊对象**， 并且具有有用的方法
2. 该方法运行并返回一个新的字符串
3. 特殊对象被销毁，只留下原始值str

注： undefined和null没有任何方法

## 数字类型
1. js中的常规数字以64位格式的IEEE_754存储。也被称为双精度浮点数
2. bigint 用于表示任意长度的整数，常规数字不能安全的超过 2 53 或小于 -2 53

数字编写方法：
1. 常规编写
2. 用下划线_作为分隔符
3. 附加字母e，来指定0的个数来缩短数字


