## new Functiony语法
语法：
```javascrpit
new Function('a','b','return a+b')// 3
```
与其他方法对比。这种方法最大的不同是在于他实际上是通过运行时通过参数传递过来的字符串创建的。
### 闭包下使用new Function
当我们使用 new Function（）创建一个函数，那么该函数的[[ Environment]]指向的是全局环境，其他函数记录的是自身创建时的环境函数，它具体指向了函数创建时的词法环境
此类函数只能访问全局变量

## setTimeout setInterval
* setTimeout 推迟到一段时间间隔之后再执行
* setInterval 重复运行一个函数，从一段时间开始间隔之后开始运行，之后以该时间间隔连续重复运行该函数
### setTimeout语法
```javascript
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
```
参数:
func: 需要执行的代码， 一般是函数
delay：执行前的延时，毫秒为单位，默认值是 0
arg1，arg2 要传入被执行函数的参数列表
如何停止：
1. setTimeout会返回一个定时器标识符
2. clearTimeout（定时器标识符 ）

### setInterval语法

### setTimeout嵌套setTimeout
* 嵌套的settimeout可以精准的设置两次执行之间的延时，二setInterval却不能
* 使用setInterval的时候，函数的实际调用间隔要比代码中设定的时间间隔要短！
* 嵌套的setTimeout能确保延时的固定 

### 垃圾回收和setTimeout setInterval的回调
* 将一个函数传入setTimeout和setInterval，会将其创建一个内部应用，并保存在调度程序中，这样即使这个函数没有其他应用，也能防止被垃圾回收
* 当函数引用了外部变量，这个函数还在，那么这个外部应用也会存在， 当我么不需要时，最好取消他

### 零延时的setTimeout
该函数被调用在当前脚本执行完成之后，立即执行
* 在浏览器中实际上不为0，浏览器会将setTimeout和setInterval的五层或者更多层嵌套调用的最小延时限制在4毫秒

### 导致浏览器的计时器变慢
* CPU过载
* 浏览器页签处于后台模式
* 笔记本电脑用的是电池供电

## call、apply
* fun.call(context,arg1,arg2) 用给定的上下文和参数调用fun
* fun.apply(context,args) 调用fun，将context作为this和类数组的args传递给参数列表

区别：
两者之间唯一的语法区别是：call期望一个参数列表，而apply期望一个包含这些参数的类数组对象
args的区别：
call可以接受...扩展运算符语法，可以将可迭代对象args作为列表传递给call，
apply只接受类数组args
args：数组最好使用apply，因为他更快
### 装饰器
* 是一个围绕改变函数行为的包装器，主要工作由该函数来完成
* 一个特殊的函数。它接受另一个函数并改变它的行为，与主函数代码分开，可以使主函数代码变得简单
### 方法借用
从一个对象中获取一个方法，并在另一个对象的上下文中调用它。
[].join.call(arguments)
从常规数组[].join中间借用join的方法，并使用[ ] .join.call在arguments的上下文中运行它

## bind 
返回值：是一个特殊的类似于函数的外来对象，他可以被调用，并且透明的将调用的传递给func 并设定this = context
bind函数的调用就是绑定了this的函数
* 绑定了上下文this和第一个参数（如果给定的情况）
* 参数arguments都被原样传递了，只是this变化了
* 绑定函数的上下文是硬绑定（hard-fixed）的。没有办法再修改this
* bind绑定后的函数和原来的对象是不同的，是另一个对象了
* 通过绑定先有函数的一些参数来创建一个新函数---偏函数应用程序
* 没有this只有参数传递的情况,原生bind不允许这样操作，手动实现：
``javascrpt
function partial(func,...argsBound){//调用的结果是个包装器
  return function(...args){//函数包装器
    func.apply(this,...argsBound,...args)//需要使用的函数
  }
}
### bindAll 
```javascrpt
for (const key in user) {
  if(typeof user[key] ==='function'){
    user[key] =  user[key].bind(user)
  }
}
```
## 箭头函数
* 箭头函数没有this
* 不能对箭头函数进行new操作，不能用作构造器
* 箭头函数没有arguments
* 没有super

## 对象深入
### 属性标志和属性描述符
对象属性标志：
* writable:true; true可以被修改，否则是可读的
* enumerable:true; 循环是否列出,是否枚举
* configurable：true；是否可以被删除，防止更改和删除属性标志，但是允许更改对象的值,单行道，无法通过defineProperty修改回来

通常这几项不会出现， 使用常用方式创建一个属性是，他们都为true
获取标志：
```javascript
let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
```
### 修改单个属性：
Object.defineProperty()
```javascript
  Object.defineProperty(obj,'name',{
    writable:false //不可修改
    configurable:false,//不可配置
    enumerable:false//不可枚举
  })
```
### 修改多个属性：
Object.defineProperties()
```javascript
Object.defineProperties(user,{
    name:{value:'wl',writable:false},
    age:{value:25,writable:true}
})
```
Object.getOwnPropertyDescriptors()
返回包含symbol类型和不可枚举的属性在内的所有属性描述符

## 对象属性的getter和setter
两种类型的对象属性：
* 数据属性
* 访问器属性，本质是用于获取和设置值的函数
### getter/setter
在对象字面量中，他们用get和set表示
```javascript
 let obj = {
     name:"john",
     surname:'smith',
     get propName(){
       return `${this.name} ${this.surname}`
     },
     set propName(value){
       [this.name,this.surname] = value.split(
         ' '
       )
     }
   }
```
### 访问器描述符
与数据属性不同， 没有value和writable属性，但是有get和set函数
访问器描述符可能有：
* get 一个没有参数的函数，再读取属性的时候工作
* set 一个带有一个参数的函数，在当属性被设置时调用
* enumerable 
* configuarble 
**一个属性要么是数据属性，要么是访问器属性，不能两者皆是如果同时出现get和value，那么会出错**

总结：
对象属性分为两种类型：
* 数据属性
* 访问器属性 

## 原型继承
### prototype 
* js对象有一个特殊的隐藏属性[[ prototype ]]，它要么为null要么就是对另一个对象的引用，该对象成为原型
* 使用obj.__proto__访问到他

###  __proto__实现继承
设置prototype的方法
使用__proto__继承的限制：
* 引用不能形成闭环
* __proto__的值可以是对象，也可以是null，其他类型会被忽略

**只能有一个[[prototype ]],一个对象不能从其他两个对象获得继承**

### __proto__和[[ prototype]]的区别
*  __proto__是[[ prototype]]的getter/setter
* 使用Object.getPrototypeOf/object.setPrototypeOf取代__proto__

### this的值
* 无论在哪里找到方法：在一个对象还是在原型中，在一个方法调用中，this始终是点符号 . 前面的对象
* 当继承的对象运行继承的方法时候，他们仅修改自己的状态，不会改变大对象的状态
* 方法是共享的，但数据不是

### 循环取值
* for...in 循环会迭代继承的属性
* obj.hasOwnProperty(key)  如果obj具有自己的（非继承的）名为key的属性，返回true，过滤原型属性

**几乎所有其他键、值获取方法都会忽略继承的属性，例如：Object.keys/Object.values**

### prototype 
F.prototype(不是[[ prototype]])仅在new F 被调用新对象的[[ prototype]] 赋值(构造函数建造对象的时候)
* 每个函数都有F.prototype属性，即使我们没有提供它
* 默认的prototype是一个只有constructor的对象， 属性constructor指向函数自身
```javascript
function say(){
    console.log('111');
}
console.log(say.prototype.constructor===say); //true
```
* 可以使用constructor属性来创建一个新对象，该对象使用与现有对象相同的构造器（适用于是用外面的库，但不确定使用了哪个构造器的情况 ）
* prototype 可以将整个默认的替换掉，那么其中就不会包括constructor了，为了确保正确的constructor ，我们可以选择添加、删除属性到默认的prototype，而不是将其整个覆盖

总结：
* 通过构造函数创建的对象设置[[ protptype ]]的方法
* F.prototype属性在new F 被调用时作为新对象的 [[prototype ]]赋值
* prototype要么是一个对象要么是null，其他值不起作用
* prototype属性仅在设置一个构造函数，并通过new操作符调用时，才具有特殊的影响
* 默认情况下 ，所有函数都有F.prototype  = {constructor:F}。所以我们可以通过访问他的"constructor"属性来获取一个对象的构造器

### 原生的原型
#### Object
* obj = {} 和obj = new Object()是一个意思。Object就是一个内建的对象构造函数，其自身的prototype指向一个带有toString和其他方法的一个巨大的对象
* obj.__ proto__=== Object.prototype
* Object.prototype.__ proto__ === null

#### 其他内建原型
* Array
* Date
* Function
...
```javascript
console.log([].__proto__.__proto__===Object.prototype);//true
console.log([].__proto__.__proto__===Object.prototype);//true
console.log([].__proto__.__proto__.__proto__);//null
```

所有内建对象的顶端都是Object.prototype
**使用原型上的方法时是会优先使用更近的方法**

#### 基本数数据类型
```javascript
console.dir(String.prototype);
console.dir(Number.prototype);
console.dir(Boolean.prototype);
```
**null和undefined没有对象包装器，没有属性和方法，并且他们没有原型**

#### 更改原生原型
* 原生的原型可以被更改
* 不建议修改
* Polyfilling （填充）是一个术语，当原生的方法在js规范中已经存在，但是js引擎不支持该方法，我们可以手动实现它，填充原型

#### 从原型中借用方法
obj.__ proto__  = Array.prototype，数组的方法可以自动在obj使用
一次只能继承一个对象， 如果已经从另一个对象进行了继承，那么这种方法也就不可行了（会覆盖已有的继承）

### 设置原型的方法
* Object.create(proto,[ descriptors]) 利用给定的proto作为 [[ prototype]]和可选的属性描述来创建一个空对象 
语法：
```javascript
let animal = {
  eats: true
};

let rabbit = Object.create(animal, {
  jumps: {
    value: true
  }
});

alert(rabbit.jumps); // true
```
* Object.getPrototypeOf(obj) 返回obj的[[ prototype]] （与__proto__的getter相同，使用__proto__读取）
* Object.setPrototypeOf(obj) 将对象obj的[[ prototype]]设置为proto （与__proto__的setter相同,设置__proto__） 
* __proto __ 只能是一个对象或者是null，如果用户使用__proto__作为键，那么会导致error
解决方式：
1.  let obj = Object.create(null) 创建的原型没有Object.prototype属性
2. Map 对象
### 浅拷贝一个对象的所有描述符，克隆可枚举的和不可枚举的以及数据属性和setters/getters(还是浅拷贝)，比for in更强大
```javascript
let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
```
总结：
* js对象都有一个[[ prototype]]的隐藏属性，它要么是null，要么是对另一个对象的引用通过__proto__访问
* __proto__实际是对于对象隐藏属性的[[ prototype]]的getter/setter
* 每一个构造函数都有prototype属性， 初始化的prototype里只会有一个constructor对象，这个constructor对象指向函数自身
* 在构造函数new一个实例的时候，会将其prototype属性赋值给实例，实例中读取构造函数的prototype是通过__proto__来进行读取
* 所有的对象都可以使用Object.prototype对象里的方法，所有的对象（Array,Date,Function都有其内置的prototype属性）
* Object.prototype.__proto__是null，原型链的终点是null
* 基本数据类型除了undefined和null，也有其prototype
* 修改原生原型： 
创建一个以什么为原型的对象：Object.create 
获取obj的__proto__  Object.getprototypeOf  
设置obj的__proto__为xxx Object.setPrototypeof(obj,xxx)

### 获取自身和获取原型属性的区别
* Object.keys/ Object.values 获取自身的可枚举的属性，不能获取原型上的属性
* for...in item是key 会获取原型上以及自身的属性的可枚举属性
* getPrototypeNames获取自身+原型上的不可枚举+可枚举的属性
* for...of item是value， 不会遍历到原型上的属性,只能遍历具有迭代器 iterator的数据， 如数组，字符串，对象不能遍历
。。。待补充

## class类
语法：
```javascript
class User{
  constructor(name){
    this.name = name
  }
  sayHi(){
    console.log(this.name)
  }
}
let user = new User('join')
user.sayHi()
```
当newu user（）被调用时
1. 一个新的对象被创建
2. constructor使用给定的参数运行， 并将其赋值给this.name
**类的方法之间没有逗号**
### 什么是class类
* 类是一种函数
class User{...}做了什么？
1. 创建一个名为User的函数，该函数成为类声明的结果。
2. 储存类的方法，例如： User.prototype中的sayHi
### 区别于其他定义构造器ES5
* 类必须使用new 操作符来调用它
* 通过class创建的函数具有特殊的内部属性标记 [[ IsClassConstructor]]:true
* 类的方法不可枚举，类定义将prototype中所有的方法的enumerable标志设为true，for...in循环时，class方法不会出现
* 类总是使用use static  自动进入严格模式

### 类表达式
```javascript
let User = class myClass {
  sayHi() {
    console.log(myClass);
  }
}
```
### getters/setters
```javascript
  class User {
  constructor(name){
    this.name = name
  }
  get name(){
    return this._name
  }
  set name(val){
    this._name  = val
  }
}
let user = new User('wl')
// console.log(user.name);
user.name = 'xc'
console.log(user.name);
```
### 计算属性名称 
 [... ] : ['say'+'hi' ]类似对象字面量

## 类继承
#### exdents
语法：
```javascript
class Animal{
  constructor(name,){
    this.speed = 0;
    this.name = name
  }
  run(speed){
    this.speed = speed;
    console.log(`${this.name} runs whit speed ${this.speed}`);
  }
  stop(){
    this.speed = 0
    console.log(`${this.name} stands still`);
  }
}
let animal = new Animal('my animal')

class Rabbit extends Animal{
  hide(){
    console.log(`${this.name} hides `);
  }
}
let rabbit = new Rabbit('whith Rabbit')
rabbit.run(5)
rabbit.hide()
console.log(Rabbit.prototype.__proto__===Animal.prototype);//true
console.log(rabbit.__proto__.__proto__===Animal.prototype);//true
```
* Child.prototype.__proto __ == Parent.prototype
* 关键字extends使用了很好地旧的原型机制进行工作，它将Rabbit.prototype.[[ prototype]]设置为 Animal.prototype
* 如果在Rabbit.prototype中找不到一个方法， js就会从Animal.prototype中获取
* exdents 后允许任意表达式
```javascript
function f(phrase){
  return class {
    sayHi(){
      console.log(phrase);
    }
  }
}
class User extends f('hello'){}
let u = new User()
u.sayHi()
```
* 子组件继承的方法，可以被重写

#### super()关键字调用父类的方法
* super.method(...)调用父类一个方法 
* super() 调用一个父类的constructor（只能写在constructor中）

#### 重写constructor
* 一个类继承另一个类，并且没有constructor，那么会生成空的constructor
* **继承类的constructor必须调用super（），并且要在使用this前调用**
为什么？
* 当通过new 执行一个常规函数时候，他将创建一个空对象，并将空对象赋值给this （常规是先创建空对象，在通过this赋值）
* 当类 继承的constructor执行时，他不会执行此操作，它期望父类的constructor来完成这项工作（class是需要先有this，在赋值）
* 派生的（子类）的constructor必须调用super才能执行其父类的constructor，否则this指向的那个对象永远不会创建，并且会报错
* 父类的构造器总是会使用它自己字段的值，而不是被子类重写的那一个

 #### [[ HomeObject]]用于super的实现，为什么通过super（）可以调用父组件的constructor
* 单纯通过this指向来执行__proto__会造成循环引用
* 在js中，[[ HomeObject]]仅被用作super
* [[ HomeObject]] 不能被修改， 他会记住他们的对象。
**箭头函数没有自己的this或super，他们能融入就近的上下文，就像透明的

## 静态属性和静态方法
定义： 可以把一个方法作为一个整体赋值给类，这样的方法被称为静态的
### 静态方法
语法：
```javascript
class User {
  static staticMethod() {
    alert(this === User);
  }
}

User.staticMethod(); // true
```
* static方法的this指类本身
* static声明的方法是整个class类的方法

### 静态属性
```javascript
class User {
  static publisher  = 'levi ding'
}
```
### 继承静态属性和方法
子类可以继承父类的静态属性和方法
原理：
使用原型，extend使子类的[[ prototype]]指向了父类(Child.__proto __=== Parent)。
子类函数原型继承父类
子类的prototype指向父类的prototype
子类实例的 __proto_ _指向其构造函数

### class Rabbit extends Object和 class Rabbit的区别
class Rabbit extends Object意味着：
1. Rabbit.prototype.__proto __ === Object.prototype
2. Rabbit.__proto __ === Object

class Rabbit 意味着：
Rabbit.__proto __ ===Function.prototype

## 私有的和受保护的属性和方法
### 内部和外部接口
* 内部接口：可以通过该类的其他方法访问但不能从外部访问的方法和属性
* 外部接口：也可以从类的外部访问的方法和属性
### 类中如何确定私有的
* 受保护的属性通常以下划线 _作为前缀， 是约定俗成的
* 只读的，只给类中的属性设置getter，而不设置setter
* 语言级的支持， 方法和属性名前添加 #  表示该字段为私有的特殊标志，我们无法从外部或继承的类中访问他

### 封装：
面向对象编程而言，外部接口和内部接口的划分被称为封装

## 扩展内建类
```javascript
 class PowerArray extends Array{
            isEmpty(){
                return this.length ===0
            }
            // static get [Symbol.species](){
            //     return Array
            // }//Symbol.species是其以什么构造函数去构造实例，这里返回的是array,会导致 实例不能使用PowerArray身上的方法

        }

        let arr = new PowerArray(1,2,3,4,5,10,60)
        alert(arr.isEmpty())
        let fiterArr = arr.filter(item=>item>=10)
        console.log(fiterArr);
        console.log(fiterArr.isEmpty());//可以在filter结果数组上继续使用powerArray的方法

```
### 内建类没有静态方法继承

## 类检查 ：instanceof
作用： 用来检察一个对象是否属于某个特定的的class，同时它还考虑继承
instanceof操作符
语法：
```javascript
obj instanceof Class
```
* obj隶属于Class类或者class衍生类，则返回true
* 和构造函数一起使用
* 与Array之类的内建class一起使用
* instanceof 在检查中会将原型链考虑在内
obj instanceof Class算法执行的大致过程：
1. 如果这有静态方法 symbol.hasInstance 直接调用（执行instanceof 时会直接调用）
2. 没有Symbol.hasInstance方法的情况下：
obj._ _proto__ === Class.prototype? 
obj._ _proto__._ _proto__ === Class.prototype?
obj._ _proto__._proto__._proto__=== Class.prototype?
如果任意一个答案为true。那么就返回true，
如果已经检查到了原型链的尾端都没有，则返回false
* 对于实例。只需要对比一次
* 对于继承，需要对比两次
### objA.isprototypeOf(objB) 
如果objA处于objB的原型链中， 则返回true，但是class的constructor自身是不参与检查的，检查过程之和原型链以及class.prototype有关

### Object.prototype.toString方法来揭示类型
可以将其视为typeof和instanceof的替代版来使用

#### Object.prototype.toString.call(arr)
```javascript
console.log(  Object.prototype.toString.call([]));//Array
console.log(  Object.prototype.toString.call({}));//Object
console.log(  Object.prototype.toString.call('213'));//String
console.log(  Object.prototype.toString.call(123));//Number
console.log(  Object.prototype.toString.call(NaN));//Number
console.log(  Object.prototype.toString.call(true));//Boolean
console.log(  Object.prototype.toString.call(null));//Null
```
使用call方法在上下文this=arr中执行函数toString
#### Symbol.toStringTag
* 自定义对象的toString方法
```javascript
let user = {
    [Symbol.toStringTag]:'user'
}
alert({}.toString.call(user))
console.log(window[Symbol.toStringTag]);//Window
console.log(XMLHttpRequest.prototype[Symbol.toStringTag]);//XMLHttpRequest
console.log({}.toString.call(window));//[object Window]
console.log({}.toString.call(new XMLHttpRequest()));//[object XMLHttpRequest]
```

## 类型检查方法总结
* typeof 用于原始数据类型，无法区分array/object 返回值：string
* {}.tostring 用于原始数据类型，内建对象， 包含symbol.toStringTag属性的对象  返回值 ：string
* instanceof 用于对象，检查是否存在原型链上、是否继承 返回值：true/false 适用于类的层次结构
* constructor 返回所有变量的构造函数

## class类总结
* class类本质是一种函数，与ES5不同的地方：必须new ，方法属性不可枚举，自动开启严格模式
* get/set 给属性添加getter/setter
* 类的继承通过extends关键字实现继承，将子类的prototype.__proto__ ==父类的prototype
* 子类的constructor构造器必须使用super（）函数，这是因为class类是先绑定的父类的this在父类的constructor里来完成工作，而es5的new一个对象是先创建一个空对象，再将空对象赋值给this
* super（）基于[[ homeObject]]实现
* class中定义一个静态属性和方法 使用关键字static ，供给class类使用，并且可以实现继承
* 类中的私有属性（受保护属性）可以使用约定俗成的 _下划线命名法、只设置getter不设置setter方法、方法属性前添加#来给class类添加语言特性、
* 类检查 instanceof，检查左边的是否位于右边的原型上顺着__proto__去查找

## Mixin模式
概念： 包含可被其他类型使用而无需继承的方法的类
Mixin： 是一个通用的面相对象编程术语： 一个包含其他类的方法的类

## try...catch
语法：
```javascript
try{
  ...代码
} catch(err){
  //错误捕获
}
```
* try...catch的代码会先执行try,遇见错误的代码再执行catch
* try...catch仅对运行时的error有效，必须是有效地JavaScript代码，如果代码包含语法错误，那么try...catch将无法正常工作
* try...catch是同步代码，里面的异步代码会被忽略
* catch(err) js生成一个包含有关其详细信息的对象， 然后该对象作为参数传递给catch
  * ReferenceError error名称
  * message 关于error的详细文字描述
  * stack 当前的调用栈，目前调试目的的一个字符串

* catch可以不包括err
* try...catch...finally 都是局部变量


### throw操作符
throw会生成一个error对象
语法
```javascript
  throw  {name:'dd',message:'11'}
```

### js内建的标准error构造器
```javascript
        let error = new Error('wer')
        let syntaxerror = new SyntaxError('wer')
        let referenceerror = new ReferenceError('wer')
        console.log(error);
        console.log(syntaxerror);
        console.log(referenceerror);
```

### 再次抛出错误
catch应该只处理他知道的error，并‘抛出“所有其他的error
* 使用instanceof判断类型

### finally
```javascript
        try {
            alert('try')
            if(confirm('Make an error ?'))BAD_CODE()
        } catch (error) {
            alert('catch')
        }finally{
            alert('finally')
        }
```
* finally 句子通常用在：当我们开始做某事的时候，希望无论出现什么情都要完成某个任务
* 在try中有一个return， finally会控制转向外部代码前被执行，也就是finally会先执行
* try...finally也是有效地， 不想处理error的情况

### 全局catch 
* 浏览器环境： window.onerror 
作用： 将错误信息发送给开发者
```javascript
<script>
  window.onerror = function(message, url, line, col, error) {
    alert(`${message}\n At ${line}:${col} of ${url}`);
  };
  function readData() {
    badFunc(); // 啊，出问题了！
  }
  readData();
</script>
```
## 自定义error，扩展error
* 可以正常从Error和其他内建的Error类中进行继承
* name属性可以通过 this.name = this.constructor.name来获取正确的类名
* instanceof来检查特定error，第三方库可以使用name属性来检查
* 包装异常：用于处理低级别异常并创建高级别error而不是各种低级别error的函数

## 回调
JavaScript主机（host）环境提供了许多函数，这些函数允许我们计划异步行为，换句话说，我们现在开始执行的行为，但他们会在稍后完成
setTimeout就是异步函数
* 基于“回调”的异步编程风格， 异步执行某项功能的函数应该提供一个callback参数用于在相应事件完成时调用
```javascript
  function loadScript(src, callback) {
            let script = document.createElement('script')
            script.src = src
            script.onload = ()=>callback(script)
            document.head.append(script)
        }
        loadScript('./test.js', function(script){
            console.log(script);
            newFn()
        })
```
* 在回调中回调
需要继续嵌套写
```javascript
    loadScript('./test.js', function(script){
            console.log('执行回调1');
            loadScript('./test2.js', function(script){
            console.log('执行回调2');
             
            })
        })
```
* 处理error
 Error优先回调
约定：
1. callback的第一个参数是error而保留的，一旦出现error，callback（err）会立刻调用；
2. 第二个参数用于成功的结果，此时callback（null，result1，result2 ）就会被调用。。。
 ```javascript
     function loadScript(src, callback) {
            let script = document.createElement('script')
            script.src = src
            script.onload = () => callback(null, script)
            script.onerror = () => callback(new Error(`no script src ${src}`))
            document.head.append(script)
        }
        loadScript('./2test.js', function (err, script) {
        if (err) {
            console.log(err);
        } else {
            //正常处理业务逻辑
        }

        })
```
## promise
语法：
```javascript
 let promise =  new Promise(function (resolve,reject){
      //executor
 })
 ```
### executor
* executor自动调用
* executor接受两个参数：resolve，reject

*   当new Promise被创建时，executor会自动运行，他包含最终应产出结果的生产者代码。
* resolve,reject 是由JavaScript自身提供的回调，我们的代码再executor的内部
  * resolve（value）： 如果任务成功完成并带有结果value
  * reject （error）： 如果任务出现error， error即为error对象
总结： executor会自动运行并尝试一项工作， 尝试结束后，如果成功则调用resolve，如果error则调用reject

### new Promise promise返回的对象
* state ： 最初是peding,resolve被调用时：fulfilled，reject被调用时变为：rejected
* result ：最初是undefined，resolve(value)被调用时为value，reject（error）被调用时 为error
最终的两种状态：
1. state：'peding',result:undefined ====> state:'fulfilled' ,result:value
2. state:'peding',result:undefined =====> state:'rejected',result:error
* 只会有一个结果或者一个error，任何状态的改变都是最终的，不会再变了

### then, catch,finally
将结果或error，使用then，catch，finally为消费函数进行注册
#### then
```javascript
let promise = new Promise(function (resolve, reject) {
            console.log(1);
            setTimeout(() => {
                // resolve(123)
                reject(new Error('whoops'))
            }, 1000);
        })
        promise.then(
            (value) => {
                console.log(value);
            }, (err) => {
                console.log(err);

            }
        )
```
* 第一个参数是一个函数， 该函数在promise resolved之后运行并接收结果
* 第二个参数也是一个函数，该函数在promise rejected后运行并接受error
* then可以只编写一个，只编写一个就是只有成功的回调

#### catch

```javascript
let promise = new Promise(function (resolve, reject) {
            console.log(1);
            setTimeout(() => {
                // resolve(123)
                reject(new Error('whoops'))
            }, 1000);
        })
        promise.catch(

            (err) => {
                console.log(err);

            }
        )
```
只对error感兴趣的情况
是对.then(null,f)的模拟，是一个简写语法糖

#### finally
* 类似常规try...catch...finally ，总是在promise被resolve或者reject时执行
* 执行清理的很好处理程序，例如无论结果如何，都停止使用不再需要的加载指示符

#### promise和普通回调的区别
* promise允许我们按照自然顺序进行编码
* 可以根据需要，在promise上多次调用.then每次调用都会在订阅列表中添加一个新的回调函数

#### .then返回promise 构建异步行为链

## 使用promise进行错误处理
* 在链式调用.then的结尾使用.catch，捕获错误
* 隐式try...catch,catch不仅会显示捕捉rejected，还会捕捉它上面的处理程序意外出现的error
```javascript
 new Promise((resolve,reject)=>{
    throw new Error('whoops')//隐式抛出错误，变为rejected
}).catch(err=>alert(err))
```

### 再次抛出
* .catch处理完成后，下一个成功的.then处理程序就会被调用
* .catch不能处理的错误，会抛给下一个.catch里去处理

### 未处理的rejection（全局事件捕捉）
对于在 promise 中未被处理的 rejection：脚本死了，并在控制台留下错误信息
js会生成全局error， 使用onhandledrejection（html标准） 事件来捕捉此类error

## Promise API 
promise中有六类静态方法
### Promise.all

#### resolve的情况：
* 当给定的promise都resolve时， 新的promise才会resolve，将结果数组成为新promise的结果。
* 结果数组与源promise的顺序相同，即使花费的时间不一样

#### reject的情况
* promise.all任意一个promise被reject， 由Promise.all返回的promise就会立刻reject，并且带有的就是这个error
* 如果出现了error，其他promise将会被忽略，立马reject，完全忽略列表其他promise，他们的结果也会被忽略

#### 允许除了promise之外的其他值，promise.all会按照原样传递给结果数组
```javascript
   let p =   Promise.all([
            new Promise((resolve,reject)=>{setTimeout(() => resolve(1), 1000)}),
            2,
            {name:'xwl'}
        ])
        p.then(console.log) //[1,2,{name:'xwl'}]
```

#### Promise.allSettled返回所有的promise数组
```javascript
 Promise.allSettled(
           urls.map(url=>fetch(url))
        ).then(results=>{
            console.log(results);
            results.forEach((result,num) => {
                if(result.status==='fulfilled'){
                    console.log(`${urls[num]}: ${result.value.status}`);
                }else{
                    console.log(`${urls[num]}: ${result.reason}`);

                }
            });
        })

```


##### polyfill Promise.addSettled
```javascript
        Promise.myAllSettled = function (promises) {
            const convertedPromises = promises.map(p => {
               return Promise.resolve(p).then((value)=>{
                   return {status:'fulfilled',value}
                }, (reson)=>{
                    return {status:'rejected',reson}
                })
            });//返回一个全部为成功的promise数组， 其中包括失败的和成功的
            return Promise.all(convertedPromises);
        };
```

### Promise.race
只等待第一个settled的Promise并获取其结果，成功或失败都可以

### Promise.any
* 只等待第一个fulfilled的promise，并将这个fulfilled的promise返回
* 如果promise都rejected，那么则返回javascript标准内置对象： AggregateError,可以在AggregateError错误类型的error实例的error属性中可以访问到失败的promise的error对象

### Promise.resolve/reject
Promise.resolve(value),用结果value创建一个resolved的promise
Promise.reject(error) 用error创建一个rejected的promise
### 总结：
* **Promise.all(promises)** 等待所有的promise都变成resolve，返回存放他们结果的数组， 如果给定的任意一个promise为reject，那么他们就会变成Promise.all的error， 所有其他promise的结果都会被忽略
* Promise.race(promises) 返回第一个fulfilled或者rejected的promise
* Promise.allSettled(promises)返回所有的promise结果以对象数组的形式返回他们的结果 {status："fulfilled/rejected",value:/reson}
* promise.any(promises) ES2021年新增， 等待第一个fulfilled的promise，将其作为结果返回， 所有的promise都为rejected，会抛出一个aggregateError错误类型的error实例
* promise.resolve(value) 使用给定value创建一个resolve，promise
* promise.reject(value) 使用给定error创建一个rejected的promise
* promise.then 没有return了 返回undefined
### promisifacation 
定义：指接受一个回调的函数转换为一个返回promise的函数
promisify 即指 promise 化
包装promisefy函数
```javascript
  //传入一个函数使其promisefy
         function promisefy(f,manyArgs = false){
             return function (...args){
                 return new Promise ((resolve,reject)=>{
                     function callback(err,...rest){
                         if(err){
                             reject(err)
                         }else{
                             resolve(manyArgs?rest:rest[0])
                         }
                     }
                      
                 args.push(callback)
                 f.call(this,...args)
                 })
             }
         }
```
## 微任务 Microtask
Promise的.then .catch .finally都是异步的

### 微任务队列 Microtask queue
 v8术语
* 队列： 先进先出，首先进入队列的会先执行
* 只有在JavaScript引擎中没有其他任务在运行时，才开始执行任务队列中的任务
当一个promise准备就绪时， .then/.catch/.finally会被放入微任务队列中，但他们不会立即被执行， 当JavaScript引擎执行完当前代码，他会从队列中获取任务并执行它

出现错误的情况：
如果一个promise的error未被在微任务队列的末尾进行处理，没有.then/catch/finally 则会出现未处理的rejection,浏览器的unhandledrejection会捕捉到这个错误.

## async/await
### Async function
```javascript
  async function f(){
               return 1
           }
           f().then(alert)
```
* async加在函数的开始： 即这个函数总是返回一个promise，其他值被自动的包装在一个resolved的promise中
* async 确保一个函数返回一个promise， 也会将非promise的值包装进去

### Await
* 只在async函数中工作
* await让JavaScript引擎等待直到promise完成settle并返回结果
* **await会暂停函数的执行**，直到promise的状态变为settled，然后以promise的结果继续执行，这个行为不会浪费CPU资源， js可以同步进行其他任务，执行其他脚本
* 不能在普通函数内执行await
* await 可以在一个支持.then的对象中使用await， 允许使用 thenable对象（那些具有可调用的then方法的对象）
* 在class中使用 直接加上async即可

### error处理
* 函数内使用try...catch
```javascript
  async function f() {
            try {
                await Promise.reject(new Error('whoops'))

            } catch (error) {
                alert(error)
            }
        }
        f()
```
* 在函数调用的后面使用.catch()来处理这个error

**使用了async、await就不用.then/catch了， 并且使用的是try...catch代码块包裹错误，而不是使用.catch**

### async/await可以和Promise.all一起使用

### 总结
async：
* 让这个函数总是返回一个promise
* 允许函数内使用await

await:
* js引擎会等待该promise settle
* try...catch来包裹错误

async、await是基于promise的

## 使用 “ownKeys” 和 “getOwnPropertyDescriptor” 进行迭代
* 在Proxy中使用ownKeys来拦截for...in对user的遍历，并使用Object。keys和Objeck.values来跳过下划线_开头的属性
```javascript
let user = {
    name:'join',
    age:30,
    _password:"***"
}
user = new Proxy(user,{
    ownKeys(target){
        return Object.keys(target).filter(key=>!key.startsWith('_'))
    }
})
for (const key in user) {
     alert(key) //name.age
}
alert(Object.keys(user))
alert(Object.values(user))
```
* 如果Proxy中不存在的键， O布局额常用，keys不会列出ownKeys返回值，因为Objeck.keys返回的仅仅是存在带有enumerable标志的对象，可以拦截[[ GetOwnProperty]]的调用并返回enumerable：true的描述符
```javascript
user = new Proxy({},{
    ownKeys(target){
        return  ['a','b','c']
    },
    getOwnPropertyDescriptor(target,prop){
        return{
            enumerable:true,
            configurable:true
        }
    }
})
for (const key in user) {
     alert(key) //a,b,c
}
alert(Object.keys(user))
```

### 具有deleteProperty和其他捕捉器的受保护属性
* 约定俗成： 以下划线_开头的属性和方法是内部的，不应从对象外部访问他们

### Proxy中的has(target,prop){}方法
* 调用in操作符检查是否存在proxy对象中，会调用proxy中的has方法

### 包装函数：“apply”
```javascript
function delay(f,ms){
    return new Proxy(f,{
        apply(target,thisArg,args){
            setTimeout(() => {
                return target.apply(thisArg,args)
            }, ms);
        }
    })
}
function sayHi(user){
    alert(`hello,${user}!`)
}
sayhi= delay(sayHi,2000)
alert(sayhi.length)
sayhi('join')
```
参数：target：目标对象； thisSArg是this的值；args是参数列表
* 使用proxy代替包装函数可以将所有东西转发到目标对象（name，length属性）

## Reflect
内建对象，简化proxy的创建
* **对于每个可被Proxy捕获的内部方法，在Reflect中都有一个对于的方法，其名称和参数与Proxy捕捉器相同**----所以我们使用Reflect来将操作转发给原始对象，捕获器get和set都透明的好像不存在一样，将读取/写入操作转发到对象
* Reflect.get 读取一个属性对象
* Reflect.set 写入一个对象属性，写入成功返回true，失败返回false

