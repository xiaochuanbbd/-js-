### 转数字：
NaN的情况：
* undefined,
* {}/{name:""},
* '123字符串'

0的情况：
* false
* null

true转为1

### 转布尔值
几种专为false的情况：
* 0
* -0
* undefined
* null
* NaN
* ''

## 基础运算符
### 一元运算符
#### 数学 % 取余 
a % b 的结果是a整除b 的余数 
** 求幂
求几次方
### +号
用于字符串拼接：
**只要有任意一个字符元另外一个也会转换为字符串**
按照顺序工作
console.log('1'+2+1);//121 ‘1’+2 = ‘12’+1  = ‘121 先执行字符串拼接，再执行数组加运算符
console.log(2+2+'1');//41 先执行加运算符，再执行拼接字符串
### 二元运算符（两个运算元参与运算）
* 唯一支持字符串运算，其他都只支持数字
* 将运算元转换为数字
### 一元运算符 +（一个运算元参与运算）
* 对数字没用 +（-2） = -2
* 对其他数字。会将其转换为数字
* 效果等同于Number（）
### 运算符优先级
* 一元运算符优先级最高
* 赋值运算优先级最低
* 逗号运算符更低

## 值的比较
* 大于>
* 小于<
* 等于 == 
* 不等于 ！=
 
### 比较运算符
1. 不同类型的值进行比较，先转换为数字在比较大小
2. 字符串类型比较会根据“词典”顺序逐字符的比较大小
普通相等无法区分0 和false 

* 严格相等 ===  
* 严格不想等 ！==
需要区分 0和 false的时候使用
不会做类型的转换
### undefined和null的比较
undefined===null //false
undefeated == null //true 因为都转为 0
### null 和 0 的比较
null ==0 //false
null>0 //false
null >=0 //true 

### undefined 和 0 的比较
undefined ==0 //false
undefined >0 //false
undefined >=0 //false
**在全等情况下undefined和null只会和各自相等，不会和任何数相等**

### 空值合并运算符??
 1. 所第一个参数不是null或者不是undefined 则？？返回第一个参数，否则返回第二个参数
 2. 提供了一种从列表中选择第一个 “已定义”的值的简便方式
 被用于为变量分配默认值
 3.？？优先级非常低， 仅高于 = 和 ？ 在使用的时候，要加括号
 4.没有明确加括号， 不能和 ｜｜ 或者 && 一起使用
 
 ## 循环
 * wihle
 * for 
 ### 跳出循环
 * break  跳出循环 
 * continue 跳出本次循环
 * outher: for(...)标签标注法，指定标签。可以跳出这个循环

###  switch语句
* case 语句执行**严格相等**
* 没有breach 后面的语句都会执行
* 任何表达式都可以成为switch/case的参数
* 可以对case进行分组 
  case 3:
  case 6:
  ...;
  breack;
switch (x){
    case 'value1': //if (x==='value1') 严格相等
    console.log(1);
    break;
    case 'value2':
        console.log(2);
        break;
        default:
            console.log('nodefined');
            break
}

## 函数
1.  函数可以从内访问外部的变量，外部无法看到内部的局部变量
2.  函数可以没有返回值，没有的时候返回的是undefined

函数参数：
* 参数 parameter（范围）：是函数声明是括号内列出的变量（ 形参）
* 参数 argument  是函数在调用时传递给函数的值（实参）

默认值：
1. 使用 = 为函数声明中的参数指定所谓的默认值
foo(from,text='xxx'){}
2. 参数默认值可以用更复杂的表达式/函数，并且只会在缺少参数才会被计算和分配 

返回值：
* 空值的return 或 没有return的函数返回值都为undefined
* return 代码跨多行 可以加上括号

### 定义函数的方式
1. 函数声明 
function sayHi(){}
结尾没有分号
2. 函数表达式 
let hi = function () {}
结尾有分号因为是在执行赋值语句

#### 函数是一个值，不加（）是输出函数体的字符串，加括号是调用

### 回调函数 
### 匿名函数

### 函数声明 vs 函数表达式
1. 语法 赋值语句和单独的语句
2. 创建时机
    函数表达式： 在执行赋值语句的时候创建
    函数声明：在被定义之前，就可以被调用。函数声明在其被**声明的代码块内的任何位置** 都是可见的。
3. 作用域
    函数声明：仅作用于本作用域
    函数表达式：赋值操作全局都可见

## 箭头函数
书写方式：
* 不带花括号，可以直接书写函数计算表达式，并返回其结果，不需要return
* 带花括号 ，必须显示的return来返回一些内容

## 八种数据类型
* number
* string
* bigint -- 任意长度的整数
* boolean
* undefined
* null 
* object
* symbol

## 调试工具

## 使用ESLint
1. 安装node。js
2. npm install -g eslint
3. 根目录下创建一个 .eslintrc的配置文件
4. 在集成了 ESLint 的编辑器中安装/启用插件。大多数编辑器都有这个选项

## polyfills和转译器
* polyfills 垫片
    * core js 
    * polyfill.io
* Transpilers 转译器
  * babel

## 对象
### 创建方式
 * 构造函数语法 let user = new Object() 
 * 字面量语法 let user = {}

### 计算属性
 * 在对象字面量中使用方括号，这叫计算属性
 * 从属性名中读取应该是从方括号中的变量中获取
 * 允许任何属性名和变量

### 属性名称限制
 * 没有任何限制，可以使用关键字和保留字
 * 当数字0 被用作对象属性的键时，会被转换为字符串 “0”

### 访问
* 点符号
* 方括号，允许读取变量

### delete 删除属性


 ### 检查属性是否存在 in 操作符
 
 ### for...in 循环
 遍历一个对象的所有键
 **对于一个整数会有排序** 

### 对象的引用和复制
* 对象储存的是改对象的“在内存中的地址”--换句话说就是该对象的引用
* 当一个对象变量被复制 --引用被复制，而该对象自身并没有被复制

### 对象的比较
* 当引用同一个地址值，相等
* 当两个对象都为空时，不相等

### 克隆与合并
#### 浅拷贝 Object.assgin（）用法
* 第一个参数指目标对象
* 后面的参数是原对象,可以使用数组，会对数组的内容进行拼接
* 如果被拷贝的属性的属性名已经存在，那么它会被覆盖
* 代替for in 进行简单克隆

### 深层克隆
object.assgin / ...扩展运算符 对于基本数据类型可以使用，但对于对象里面的引用类型无法使用。

**使用const声明的对象也是可以被修改的**

## 垃圾回收
### 可达性 
1. 可达值的基本集合，不能被释放的值（不会被垃圾回收的）：
* 当前执行的函数。它的局部变量和参数
* 当前函数嵌套调用链上的其他函数， 它们的局部变量和参数 （闭包）
* 全局变量
* 内部的变量 （根） window？
2. 一个值通过引用或者引用链从根访问任何其他值，则认为该值是可达的
例如：全局变量中有一个对象，并且该对象的属性引用了另一个对象，则该对象是可达的
3. 几个对象相互引用。但外部没有对其任意对象引用，这些对象也是不可达的（一座孤岛）

### 内部算法 
定期执行垃圾回收步骤
1. 垃圾收集器找到所有的根，并记住他们
2. 遍历并标记来自他们的所有引用
3. 遍历标记的的对象，并标记他们的引用，所有遍历到的对象都会被记住， 以免将来再次遍历到从一个对象
4. 重复操作，直到所有可达的引用都被访问到
5. 没有被标记的对象会被删除

### 优化建议
* 分代收集：对象被分为新的和旧的，旧的检查频率会减少
* 增量收集：将垃圾收集工作分成几部分来做 
* 闲时收集  cpu空闲的时候来运行

### 总结垃圾回收
* 垃圾回收是自动完成的，无法强制执行或者阻止执行
* 当对象是可达状态，他一定存在内存中
* 当引用的根引用不可达，一组相互连接的对象整体都不可达

## this
### 方法中的this
* this的值就是在点之前的这个对象， 即调用该方法的对象
* this是在代码运行时计算的，取决于代码上下文
* 在没有对象的情况下 this是全局对象window

### 箭头函数没有自己的this
* this取决于外部“正常”的函数

## 构造器和操作符“new”
### 构造函数
* 命名以大写字母开头（约定俗成）
* 只能有new操作符来执行

### new操作符执行时的步骤
1. 一个新的空对象被创建并分配给this
2. 函数体执行时，会修改this， 为其添加新的属性
3. 返回this的值

### 函数构造器的目的是--实现可重用的对象创建代码

**new function （立即调用的构造函数）不能被再次调用，因为他不保存在任何地方，只是被创建和调用**

### 在某些库的源码可能会加上这么一句
if (!new.target) { // 如果你没有通过 new 运行我
    return new User(name); // ……我会给你添加 new
  }
这表示无论是否使用new 程序都能正常工作

### 构造器的return
通常构造器是没有return语句，他的任务是将所有必要的东西写入this
* 如果return返回的是一个对象， 则返回这个对象，而不是this
* 如果return返回的是一个原始类型，则忽略
ps: return只返回带有的对象，其他都返回this

### 可选链" ？."-----对象出现不存在属性的问题 
 检查左边部分是否为undefined，如果是直接返回undefined
语法： let user = null
user?.address?.street //undefined
注意：
* 不要过度使用可选链
* ？.前的变量必须已经声明
* 会产生短路效应
* 其他变体： ?.() 调用函数 ?.[]方括号访问属性

总结：
* obj?.prop
* obj?.[prop]
* obj?.method()


## symbol类型
规范： 属性健只能是字符串类型或者Symbol类型
* 所有的symbol都是不同的
* Symbol不会被自动转换为字符串
* symbol作为键，不会被意外访问到， 是属于隐藏属性，可以和同类的字符串一起使用，但两者完全不相同
* 在对象字面量中使用Symbol，需要使用方括号括起来
```javascipt
let id = Symbol('id')
 let obj  = {
   name:'2',
   [id]:123
 }
```
* Symbol在for...in中会被跳过,Object.keys()也会被跳过
* Object.assgin 会复制Symbol
* Symbol.for(key)会创建一个全局的Symbol，全局Symbol注册相等的Symbol；
* Symbol.keyFor(key)返回Symbol（）填入的描述(只适用于Symbol.for()创建的全局Symbol)

使用场景：
* 隐藏属性对象
* js使用了许多Symbol
从技术上说，Symbol 不是 100% 隐藏的。有一个内建方法 Object.getOwnPropertySymbols(obj) 允许我们获取所有的 Symbol。还有一个名为 Reflect.ownKeys(obj) 的方法可以返回一个对象的 所有 键，包括 Symbol。所以它们并不是真正的隐藏。但是大多数库、内建方法和语法结构都没有使用这些方法。


## 对象原始值转换
转换规则：
1. 所有的对象转布尔值都为true
2. 数值转换在Data对象中可以相减
3. 字符串转换通常发生在alert（obj）这样一个输出对象

类型转换三种变体
* 对象转string  是指对一个期待字符串的对象执行操作时，例如alert 转为：[object Object] ===>先调用obj.toString或者obj.valueOf()
* 对象转number 是指进行数学运算时 ===>先调用obj.valueOf()再调用obj.toString()
* default 在少数情况下发生，当运算符不确定期望值的类型 例如： 二元加法，二元加法可以用于数字的相加也可以用于字符串拼接 ===>先调用obj.valueOf()再调用obj.toString()

转换方法：
1. 调用obj[Symbol.toPrimitive] 系统Symbol的方法
2. 字符串转换转 toString()优先 再valueOf()
3. 数学运算number/default 优先valueOf再toString()

obj.toString()返回一个字符串 "[object Object]"
obj.valueof()返回对象自身 

## obj[Symbol.toPrimitive]
let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

## 数据转换合集
1. 其他类型转布尔值
六种为false： 0 -0 null undefined NaN ""
2. 比较运算符 
转数字
3. 数学运算
转数字
4. 二元+ 
有字符串 是拼接字符串 
5. 其他类型转数字
null :0
false:0
"":0
Undefined :NaN
{}:NaN
'zifuchuan‘:NaN
6. 其他类型转字符串
对象/数组转字符串 [object Object]
 
其他直接是加引号
7. 对象进行转其他类型
转字符串 ：toString()
转数字： valueOf 

## 原始数据类型的方法
js允许访问字符串，数字，布尔值，和symbol的方法和属性，为了他们能够起作用，创建了提供额外功能的特殊“对象包装器”使用后被销毁
例子：str.toUpperCase() 包装对象的操作过程：
1. 在访问属性的时候，会创建一个**包含字符串字面值的特殊对象**， 并且具有有用的方法
2. 该方法运行并返回一个新的字符串
3. 特殊对象被销毁，只留下原始值str

注： undefined和null没有任何方法

## 数字类型
1. js中的常规数字以64位格式的IEEE_754存储。也被称为双精度浮点数
2. bigint 用于表示任意长度的整数，常规数字不能安全的超过 2 53 或小于 -2 53

数字编写方法：
1. 常规编写
2. 用下划线_作为分隔符
3. 附加字母e，来指定0的个数来缩短数字 
    let c = 7.3e9 //73000000000（这里的e是把数字乘以1后面跟着给定数量的0的数字）
    let d = 1e-6 //0.000001 (e后面的负数表示除以1后面跟着给定数量的0的数字)

八进制，十六进制，二进制

**数字的toString（）方法，需要使用..来调用  console.log(12323..toString(36)); //9ib**
### 数字舍入
* Math.floor 向下舍入
* Math.ceil 向上取整
* Math.round 向最近的整数舍入 3.1==>3  3.5==>3 3.6==>6
* Math.trunc (ie不兼容) 直接去掉小数点 不舍入

#### 将数字舍入到小数点后n位
1. 乘除法（放大倍数法） 数字 *100（一个比较大的倍数），调用舍入函数，然后在将其除倍数 
   Math.round(num * 100 ) /100//小数点后两位
   该方法可以减少误差，但不能完全消除误差
2. toFixed(n) 将数字舍入到小数点后n位，并**返回字符串** 类似于Math.round 向上或者向下舍入到最近的值
    let num = 12.34;
    alert( num.toFixed(1) ); // "12.3"

#### 数字的方法
isNaN()将其参数转换为数字，然后测试他是否为NaN
 
#### 为什么0.1+0.2 ！=0.3？

一个数字是以二进制的形式存储在内存中，一个1和0的序列。

0.1和0.2在二进制中是无限循环的小数点

IEEE-745组织将通过数字舍入到最接近的可能数字来解决这个问题，精度会丢失

#### isNaN和isFinite 
* isNaN（）将传入参数转为数字，然后测试它是否为NaN
 NaN ===NaN //false
* isFinite(value）判断是否为数字 。将其参数转为数字，如果是常规数字，则返回true, NaN/Infinity/-Infinity返回false

#### Object.is
类似于 === 比较
let a = {}
let b= {}
console.log(Object.is(NaN,NaN)) //true
console.log(Object.is(0,-0))//false
console.log(Object.is(a,b))//false
console.log(Object.is(NaN===NaN))//false

#### parseInt和parseFloat
适用于提取 “100px" "10$"这样的数据
* parseInt返回一个整数
* parseFloat返回一个浮点数
他们可以从字符串读取数字，直到无法读取位置， 如果发生error，则返回收集到的数字
返回NaN的情况
* 第一个字符就是非数字
parseInt（str,radix）参数
第二个参数可以选择解析的十六进制和二进制的字符串

区别+号和Number：
这两个无法对非数字的其他数字进行判断。他们的数字转换是严格的比如 “100px”,会返回NaN

#### 其他数学函数
* Math.random()返回从0-1的随机数 
* Math.max() 返回最大值 
* Math.min() 返回最小值
* Math.pow(n,power) 返回n给定的power次幂

#### 传入最大值最小值获得随机数
 随机生成min-max的随机数取整数
 1. 生成 0.5-3.5的值，用round 四舍五入 从而将所需的概率添加到取值范围的边界
 ```javascript
function random(min, max) {
    let rand = min - 0.5 +Math.random()* (max-min+1)
    return Math.round(rand)
}
  ```

2.用math.floor向下取整来取范围从min-max+1的随机数

```javascript
  function random2(min,max){
    let rand = min + Math.random() * (max +1 -min)
    return Math.floor(rand)
} 
  ```

## 字符串
字符串内部的格式始终是UTF-16 它不依赖于页面编码
字符串长度 str.length
### 访问字符
1. [pos] 
2. str.charAt(pos) 
两者区别：
* 找不到: []返回undefined， charAt(pos)返回“”空串

### 遍历字符串： for...of
### 字符串是不可变得 无法通过str[0] = xxx来改变
### 转换大小写
* toUpperCase 转换大写
* toLowerCase 转换小写

### 查找子字符串
* str.indexOf(substr,pos)
功能：查找字符串的位置
参数： pos给定的位置，  substr的内容
返回值：找到返回所在的位置，没找到返回-1
大小写敏感
* str.lastIndexOf()类似indexOf,从字符串的末尾开始搜索到开头
注意：
**if(str.indexOf())如果一开始就匹配到会产生 0 这个数字,永远也进不来if循环。有时候我们会见到if(~str.indexOf())这样的代码，意思是if found** 
* includes（str,pos） 
功能： 匹配字符串，但不需要他的位置 
返回值：true，false
参数： pos查询的起始位置
* str.startWith() 以什么开头 返回值 true /false
* str.endWith ()以什么结束 返回值 true /false

### 获取子字符串
* slice(start,end) （重点记住）
功能：返回字符串从start到end的部分（不包括end） 没有end,返回到结尾
参数：start，end.可以为负值，表示起止位置从字符串结尾计算
返回值：获取到的字符串
不允许start大于end
* substring(start,end)
与slice基本相同
但它允许start大于end
不能写负数，负数被视为0
* substr(start,length)
功能：返回字符串从start到给定的length部分
允许start是负数

### 比较字符串
1. 小写字母总是大于大写字母
2. 带变音符号的字母存在“乱序”的情况
str.codePoinAt(pos) 返回在pos位置的字符串码
str.formCodePoint(code) 通过数字code创建字符

### 其他字符串方法
str.trim() 去掉字符串前后空格
str.repeat(n)重复字符串n次

### 对比记忆：
* 根据下标找字符串 ：[] charAt(下标) 都是根据下标查找返回字符串， charAt找不到会返回“”
* 判断字符串是否存在 ：indexOf(字符串)返回下标 inclueds ()找字符串，返回布尔值
* 字符串截取：slice/substring ，从开始到下标位置结束； subStr 从开始到多长结束 长度

## 数组
### 声明方式
let arr = new Array()
let arr = []

### 数组方法
* unshift / shift 数组开始添加、删除一个元素，改变原数组
* push /  pop 数组末尾添加删除一个元素，改变原数组
#### 为什么push/pop比unshift/shift运行的要快
shift的操作：
1. 移出索引为 0的元素
2. 将所有的元素向左移动， 索引1改为0，索引2改为1...
3. 更新length属性
数组中的元素越多，移动他们就要花费越多的时间，意味着更多的内存消耗
pop操作：
1. 移出最后一位
2. 其他保持不变

 ### 栈和队列：
 栈：后进先出
 队列：先进先出
 js允许从首端/末尾来删除/添加数据，这样的操作叫做 双端队列

### 循环
* for  运行最快哦 兼容低版本浏览器
* for of  item为数组每一项
* forEach ((item,index,array))
* for in  不要用这个。。。

```javascript
let arr = ['apple','bule','orange']
for (const i of arr) {
    console.log(i);
}
```

清空数组： arr.length = 0
### toString
返回以逗号隔开的元素列表
数组没有Symbol.toPrimitive 方法，也没有valueOf,所以执行tostring
 []+1 =='1'
 [1]+1 =="11"
 [1,2]+1 =="1,21"

 ### 使用==比较数组
 除非引用相同，否则永远不相等

### splice 
* 功能：添加，删除和插入元素
* 参数：arr.（start,deleteCount,element1,element2)
1. start:从索引start开始删除arr,
2. deleteCount 删除几个元素 
3. ele1,ele2 当前位置插入
* 会修改后的数组
* 可以允许负向索引

### slice
* 功能：对数组进行街区
* 参数：start，end
* 返回值 返回一个新的数组，从start，到end数组项复制到一个新数组
* 可以允许负数,表示从胃部开始计算
* 不带参数调用：会创建一个副本，不影响原始数组进一步转换
### concat
* 功能：创建一个新数组 ，数组拼接
* 参数：任意数量，数组或者值都可以
* 返回值：返回一个新数组
注：拼接对象，会变成[object object]
如果类似数组的对象具有 Symbol.isConcatSpreadable 属性，那么它就会被 concat 当作一个数组来处理

### 数组搜索 
类似字符串搜索
* indexOf 查找数组所在的下标 不存在 -1 不可以处理NaN
* lastIndexOf 从最后寻找item所在的下标 不存在 -1 不可以处理NaN
* includes  查找item是否存在， 返回true/false 可以处理NaN
ps:这些方法严格比较

### 对象数组的查找：
#### 单个查找：
* find ((item,index,array)=>{...})
返回值：找到的第一个item对象，没有找到返回undefined
* findIndex((item,index,array)=>{...})
返回值：找到的item对象所在下标,没找到返回 -1
#### 多个查找
* filter
arr.filter((item,index,arr)=>{..})
功能：过滤数组
返回值： 找到第一个函数返回true的元素，返回所有匹配元素的数组，没找到返回空数组

### map
对每个数组都调用函数，并返回结果数组
返回值：返回经过函数处理的数组
不会改变原数组

### sort 
功能：对数组进行原位排序，更改元素顺序
返回值：返回排序后的数组
会改变原数组
实现排序
升序：arr.sort((a,b)=>a-b）
降序：arr.sort((a,b)=>b-a)

### reverce 
功能：数组翻转
返回值：返回颠倒后的数组，
会改变原数组


### split 和join 
* split
功能：将字符串分割为数组
参数：split(分隔符，数组长度的限制) 以什么为分割，参数2很少使用
返回值： 分割之后的数组

* join
功能：数组分割成字符串
参数： join(',")以什么分割， 
返回值： 返回拼接好的字符串

### reduce / reduceRight
#### reduce
```javascript
let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
```
功能：该函数一个接一个应用于所有数组元素， 并将其结果搬到下一个调用
参数： 
* accumulator 上一个函数调用的结果，第一次等于initial 如果有initial的话**累加器**
* item 数组每一项
* index 当前索引
* 数组本身
返回值： 返回累计的结果 

reduceRight类似reduce，只是从右边开始计算数组

### isArray
功能：判断是否为数组
返回值： 布尔值a

arr.some()/arr.every ()
返回值：布尔值
some：有一个符合就返回true， every：全部返回才返回true

## 数组方法总结：
### 添加/删除
* push 数组末尾添加一位元素 
* pop  数组末尾移除一位
* shift 数组开头移除一位
* unshift 数组开头增加一位
* splice(pos,deleteCount,...items)  添加 删除 增加 参数： 操作的下标，删除几位，添加的元素 改变原数组
* slice(start,end) 数组截取，从start到end，但不包括end 不传任何参数默认是复制一个数组
* concat 数组合并 

### 搜索数组
1. 用于对象
* find((func) 查找符合的第一位，查到返回元素，没查找返回undefined
* findindex(func)  查找符合的第一位元素的下标，查到返回元素下标，没查到返回 -1
* filter(func) 类似find， 但是返回的是符合函数的合集
2. 用于普通数组非对象
* indexOf（item，pos）pos从哪个下标开始查找 查找符合的第一位元素的下标，查到返回元素下标，没查到返回 -1
* includes(value) 如果数组有value 返回true，没有返回false
* lastIndexOf(item,pos) 类似indexof

### 转换数组
* sort(func) 对数组进行排序 内部是黑匣子 改变原数组
* map(func) 每个元素调用func的结果组成一个新的数组
* reverse() 翻转数组，返回数组。改变原数组
* split/join split将字符串转换为数组，join将数组转换为字符串
* reduce (func,initail) 对数组每一项调用func计算数组上的单个值，并在调用之间传递中间结果

### 其他
Array.isArray() 检查arr是否为一个数组
arr.some(fn)/every(fn) 对数组每一项调用fn,一项返回/全部返回结果为true/false

## 可迭代对象  Iterable Object
任何对象都可以被定制为可在for...of中循环使用的对象
* 可迭代的对象必须实现了Symbel.iterator方法
* 一个迭代器必须有next方法，它返回一个{done:Boolean,value:any} done:true表示迭代结束，否则value就是下一个值
* Symebol.iteratol方法会在执行for...of时自动调用，但也可以直接调用
* 内建的字符串和数组都实现了Symbol.iteratol方法
* 和类数组很像，都不是数组，都无法使用数组的方法
语法： 
```javascript
let range = {
	from: 1,
	to: 5
};
range[Symbol.iterator] = function() {
	return {
		current: this.from,
		last: this.to,
		next() {
			if (this.current <= this.last) {
				return { done: false, value: this.current++ };
			} else {
				return { done: true };
			}
		}
	};
};
for (const num of range) {
	console.log(num);
}
```
### Array.from(obj,[ mapFn,thisArg ])
功能：全局的方法，将其转为真正的数组
参数：
1. obj可接受一个可迭代或类数组的词；
2. mapFn 是一个函数，该函数会在对象中的元素被添加前引用到每个元素上；
3. thisArg,允许我们为该函数设置this
语法：
```javascript
let likearr = {
  0:1,
  1:2,
  length:2
}
Array.from(likearr)
```

## Map Set
### Map
是一个带键的数据项的集合，就和一个Object一样，他们最大的区别，Map允许任何类型的键；
new Map() 创建一个Map
map.set(key,value) 设置map的键和值
map.get(key) 获取键对应的值，么有则返回undefined
map.has(key) 查找map是否有key,存在返回true，不存在返回false 
map.delete(key) 删除制定的key
map.clear 清空所有的key
map.size 返回当前元素个数
* map.set返回的是map，可以直接链式调用 
map.set(key,value).set(key,value)
#### 循环map
* map.values() 遍历并返回所有的值  
* map.keys() 遍历并返回所有的key
* map.entries() 遍历并返回所有的实体
* forEach()方法

#### Object.entries(obj) Object.fromEntries map和对象相互转换
1. Object.entries(obj)
将对象转换为Map格式: [[ 'name','join"],[ 'age',23],]
语法：
```javascript
let obj = {
	name:'join',
	age:23
}
let objMap = new Map(Object.entries(obj))
```
2. Object.fromEntries(map)
1``将map转换为对象
```javascript
let map = new Map()
map.set('name',"join")
map.set('age',23)
let obj = Object.fromEntries(map)
console.log(obj);
```

### Set 
是一个特殊的类型集合---值的集合，没有键 （key）
方法：
new Set() 创建一个set，如果提供一个iterable对象。将会从数组里复制值到set中
set.add(value)  添加value，返回set本身
set.delete(value)  删除value
set.has(value) 查找value，返回布尔值
set.clear() 清空set
set.size 并不是方法， 是属性。返回元素个数

set可以使用for...in forEach遍历
注：forEach(func)func中的第二个参数index在这里为set对象的valuetarget
Map的迭代方法在Set中也适用
* set.keys () 遍历并返回所有的值
* set.values() 与map作用相同 兼容map
* set.entries () 兼容map

### Map和普通对象的区别：
* 任意键/对象都可以作为键
* 有其他的便捷方法，比如map.size属性

## WeakMap/WeakSet 弱映射和弱集合
### WeakMap
WeakMap和Map的第一个不同的点就是：WeakMap的键必须是一个对象，不能是原始值
WeakMap不支持迭代以及keys(),values(),entries(),无法循环，没有办法获取weakmap的所有键或者值
weakMap方法：
* weakMap.get(value)
* weakMap.set(key,value)
* weakMap.delete(key)
* weakMap.has(key)

#### 使用案例
* 额外数据的存储
加入使用了第三方库或者“另一个代码的一个对象”并想存储一些与之相关的数据，那么这些数据就应该与这个对象共存亡 --可以使用WeakMap
例如：一个对象的来访记录下来，他离开了，要清除这些数据，可以使用weakMap

### WeakSet
* 与Set类似，但我们只能向WeakSet添加对象，而不能是原始值
* 对像只有在其他某个（些）地方都被访问到的时候，才能留在set中
* 支持add,has,delete 方法。不支持size和keys(),不可以迭代

### 总结
* 优点： 它们对对象是弱引用，所以被他们引用的对象很容易地被垃圾收集器移除
* 被用作“主要”对象存储“之外”的辅助数据结构，一旦将对象从主存储器中删除，如果该对象仅被用作WeakMap/WeakSet的键，那么他们将会被自动回收

### Object.keys,values,entries 迭代
* Objec.keys 返回包含该对象所有key的数组
* Object.values 返回包含该对象所有value的数组
* Object.entries 返回包含该对象所有[key,value ]键值对的数组

注： map.keys()返回的是可迭代项目 ，Object.keys（）,而不是obj.keys()返回的是真正的数组

### 为什么是Object.keys()而不是obj.keys()?
* 因为灵活性更强，js当中对象是所有复杂结构的基础
* Object.keys返回的是一个真正的数组，而不是可迭代项目

⚠️ Object.keys,values,entries会忽略symbol属性
需要获得symbol可以使用
* Object.Object.getOwnPropertySymbols会返回一个只包含Symbol类型的键和的数组
* reflect.ownKeys(obj) 会返回所有的键

### 转换对象
* 对象转换数组进行计算步骤：
1. 将对象使用Object.entries()转换为数组；
2. 调用数组的方法 ，对其进行操作；
3. 使用Object.fromEntriess()将数组转回对象
```javascript
let prices = {
	banana: 1,
	orange: 2,
	meat: 4,
  };
  let doubelPrices = Object.fromEntries(Object.entries(prices).map(i=>[i[0],i[1]*2]))
  console.log(doubelPrices);
  ```

## 解构赋值
### 数组解构赋值
* 不会改变原数组
* 忽略使用逗号的元素
```javascript 
let [a,,b,c] = [1,2,3,4,5]// 2被逗号忽略
console.log(a);
console.log(b);
console.log(c);
```
* 等号右侧可以是任何可迭代对象，不局限于数组 也可以是字符串
* 实际上是对于在=右侧的值上调用for...of 并进行赋值语句的语法糖
* 赋值给等号左侧的任何内容
* 可以与Object.entries 进行循环操作 ，可以和map一起
* 交换变量值的技巧
```javascript
let a = '123';
let b = '456';
[b,a] =[a,b]
console.log(a);/// 456
console.log(b);//123
```
* ...代替其余的数组项，...xxx表示以一个参数来获取“其余”数组项目，满足项： 
 1. ...+参数名
 2. 在最后一位
* 右侧的数组比左边的变量列表短，不会报错，默认值是undefined， 可以提供默认值 
默认值可以是复杂表达式，也可以是函数调用，类似函数默认值

```javascript
let [a=1,b=2] = []
```

### 对象解构赋值
语法：
```javascript
let {height,width} = {width:100,height:100}
```
* 左侧属性名就等于的右侧的变量名列表
* 变量的顺序并不重要
* options.width 属性赋值给名为w的变量，可以使用冒号来设置变量名称
```javascript
let {height:h,width} = {width:100,height:100}
```
冒号表示“什么值：赋值给谁“
* 使用 = 设置默认值
* 可将冒号和等于结合起来使用 width:w=200 
* 具有很多属性复杂对象，可以只提取所需的内容
* 剩余模式：... 对象拥有的属性数量比我们提供的变量数量还多的情况，剩余的变量赋值到其他地方（也是一个对象）
```javascript
let obj = {
	title:'Menu',
	width:200,
	height:200,
	background:'pink'
	
}
let {width,height,...rest} = obj
console.log(width);
console.log(height);
console.log(rest);//rest ：存有剩余属性的对象
```
* 不使用let 时的陷阱
 一般使用 let {...} = {...},不使用let会报错
 问题在于： js将{...}当作一个代码块
 需要使用
```javascript
 let width,height
 ({width,height } = obj)
 ```
 * 嵌套解构
```javascript
let options = {
	size: {
		width: 100,
		height: 200
	},
	items: [ 'cake', 'dont' ],
	extra: true
};
//size和items没有相应的变量，因为我们取得是他们的内容
let { size: { width, hieght }, items: [ item1, item2 ], title = 'Menu' } = options;
console.log(width);//size 是拿不到到值得
console.log(item1);
```
### 总结 
对象解构赋值完整语法
let {prop: varName = default,...resrt} = object
 1. prop这个属性会被赋值给varName，如果没有prop，会使用默认值default
 2. 没有对应映射的对象属性会被赋值给rest对象

数组解构赋值完整语法
let [ item1 = default,item2,...rest] = array
  1. 数组的第一个元素被赋值给了item1，第二个元素给饿了item2,剩下的元素被复制到了另一个数组 rest

从嵌套数组/对象中提取数据也是可以的，此时等号左侧和等号右侧必须有相同的结构
 
## 日期和时间
new Date()
创建一个Date对象， 其时间等于 1970年1月1日 UTC+0之后经过的毫秒数 （1/1000秒）
### 方法
new Date(datestring) 如果一个参数，并且是字符串，那么他会自动解析 
new Date(yaer,mouth,date,hours,minutes,seconds,ms)
year: 必须是四位数；
mouth: 从0开始到11月结束
date:当月的具体某一天
访问日期组件：
getFullYear()获取年份 四位数
getMouth() 获取到月份 月份 0-11 
getDate() 获取当月的具体日期， 从1-31 
getHours()，getMinutes()，getSeconds()，getMilliseconds()
获取相应的时间组件。
getTime()获取当前日期的时间戳
getTimezoneOffset() 返回UTC与本地时区之间的时差 分钟为单位

### 自动校准
32日会自动校准为 31
console.log(new Date(2021,0,32)); //2021-01-31T16:00:00.000Z

### 日期转换为数字，日期差值
let date = new Date()
console.log(+date) 等同于.getTime()

### Date.now()
相当于 new Date.getTime() 但是不会去创建Date对象，更快， 不会对垃圾处理造成额外的压力

### Date.parse(str)
参数： str: 字符串里读取的日期 ps:如果给定字符串的格式不正确，会返回NAN
格式：YYYY-MM-DDTHH:mm:ss.sssZ
YYYY-MM-DD：年-月-日
T： 分隔符
HH：mm:ss.sss 时间，分钟，秒，毫秒
Z： 单个字符Z代表UTC+0时区
**区别于其他系统。js中的时间戳是以毫秒为单位的，而不是秒**

## JSON方法 
JSON.stringify 将对象转为JSON
JSON.parse 将json转回对象
### JSON 区别传统字符串
* 字符串使用双引号
* 对象的属性名称也是需要用双引号的
特定的js的对象属性会被JSON.stringify跳过
* undefined
* 函数属性
* symbol类型的键和值
### 不能循环引用，会失败
TypeError: Converting circular structure to JSON

### JSON.stringify(value,[ replacer ,space ]) 完整语法
value:要编码的值
replacer： 要编码的属性数组或映射函数
数组：[要编码的属性名 ]
函数：
```javascript
 let json = JSON.stringify(meetup,function replacer(key,value){
	 return  (key==='occupiedBy')?undefined:value
 })
 ```
space：用于格式化的空格函数 ，传入几就缩进几个空格

### toJSON
对象可提供toJSON 方法来进行JSON转换，如果可以用，JSON.stringify会自动调用它
如：日期会自动转字符串
对象提供了toJSON方法，掉用JSON.stringify会自动调用该方法
### JSON.parse()解码JSON
JSON,parse(str,func) 
第二个参数可以是函数
```javascript
let meetup = JSON.parse(str,function(key,value){
	if(key=='date') return new Date()
	return value
});
```

## 递归与堆栈
递归：当一个函数解决一个任务时候，在解决的过程中他可以调用其他很多函数，在部分情况下，函数会调用自身，这就是递归

递归深度： 最大的嵌套调用次数（包括首次）
js引擎的最大递归深度为10000以下时是可靠的

### 执行上下文和堆栈
正在运行的函数的执行过程的相关信息是被存储在其执行上下文中。
执行上下文是一个内部数据结构，它包含有关函数执行时的详细细节，当前控制流所在的位置，当前的变量，this的值，以及其他的内部细节

### 当一个函数进行嵌套调用时，将发生以下的事儿：
* 当前函数被暂停；
* 与他关联的执行上下文被一个叫**执行上下文堆栈**的特殊数据结构保存
* 执行嵌套调用
* 嵌套调用结束后 ，从堆栈中恢复之前的执行上下文，并从停止的位置恢复外部函数
 
 递归深度： 是值堆栈上下文的最大数量
 **任何递归都可以用循环来重写，通常循环变体更有效**
 
 ### 递归结构
 链表的功能：
 * 我们可以在next之外，再添加prev属性来引用前一个元素，一便轻松的来回移动
 * 我们还可以添加一个名为tail的遍历将。该变量链表的最后一个元素（并在从末尾添加/删除元素时对该引用进行更新）
 *  ……数据结构可能会根据我们的需求而变化。
缺点： 
无法很容易的通过元素的编号获取元素

总结： 
* 递归的基础是函数参数使其任务简单到该函数不再需要进行进一步调用
